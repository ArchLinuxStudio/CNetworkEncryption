# 非阻塞 I/O 模型

在上一节，通过学习阻塞式 I/O 及与线程或进程的配合，基本已经覆盖了 socket 编程的知识点，本节将更进一步，描述另外四种网络 I/O 的实现。

再复习一下，Unix 网络编程中，存在五种 I/O 模型，它们分别为：

- 阻塞式 I/O 模型
- 非阻塞式 I/O 模型
- I/O 复用模型
- 信号驱动式 I/O 模型
- 异步 I/O 模型

非阻塞模式通过为文件描述符设置非阻塞标志位，从而达到在**数据准备阶段不阻塞**的效果。注意，这里强调数据准备阶段是因为，非阻塞式 I/O 在数据从内核缓冲区复制到用户空间时依然是阻塞的。非阻塞 I/O 模式仅为文件描述符设置标志位而不进行其他动作，所以使用者还需要在后续使用 write/read 等调用配合循环，手动对数据进行轮询的操作。

## 非阻塞的磁盘文件操作

这里首先给出一个非阻塞式 I/O 操作文件的例子。此例子接收输入，并将一些内容输出至标准输出与标准错误。同时将标准输出的文件描述符设置为非阻塞的标志位。

[none_block_file](../src/network/advanced_io/none_block_file.c ':include')

编译后执行如下命令，可以看到输入普通文件，并将输出导入 tmp.file 时，可以观察到终端无错误输出，数据在 tmp.file 正确存储，一次完成。

```bash
./a.out < /etc/services > tmp.file
```

而执行如下命令，将标准输出输出到终端，将标准错误输出到指定文件，可以看到很多错误信息在这个文件中，可以看到错误代码为 11,错误消息为`Resource temporarily unavailable`。通过查阅头文件得知，11 号错误正是 EWOULDBLOCK，也即 EAGAIN，代表 Operation would block，Try again。这是因为终端设备一次可以接受的数据量不会达到这么大，所以在持续写入时会发生如此的错误。

```bash
./a.out </etc/services 2>stderr.out
```

## 非阻塞的简易网络服务器

看过非阻塞式的本地文件处理，再来看一下非阻塞式的 socket 服务端是如何实现的。其也可用上一章节中的循环客户端程序来测试。可以看到，程序可以以非阻塞的形式处理 accept 连接，读取客户端数据，以及向客户端发送数据。但是非阻塞 I/O 模式的实现需要轮询，这样会占用相当多的 cpu 资源。同时，在轮询的间隔也不好掌握。同时，如果服务端程序已经在等待一个客户端的输入，那么后续到来的客户端将被阻塞，因为此程序同时只能对一个文件描述符进行监视，这也是为什么 I/O 多路复用模型存在的重要原因。

[none_block_server](../src/network/advanced_io/none_block_server.c ':include')

## 非阻塞的较完善的网络服务器

如果对上面的程序加以改动，可以用一个链表加轮询的方式，实现一个以类似 select/poll 的方式，完成同时多个客户端 socket 进行服务的程序。这个程序首先以非阻塞配合轮询的方式接收来自客户端的请求，随后接收客户端的请求，并将套接字加入链表，最后再以轮询的方式检查客户端套接字中是否有可读事件。如果你不能很好的理解，你也可以在看完下面将描述的 I/O 多路复用模型后再回来品味这个程序。

[none_block_server_enhance](../src/network/advanced_io/none_block_server_enhance.c ':include')
