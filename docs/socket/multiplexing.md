# I/O 多路复用模型

I/O 多路复用模型最明显的好处是可以在同一个进程中监听多个文件描述符，也即一个进程同时处理多路 IO。I/O 多路复用模型最典型的实现分别为 select,poll 以及 epoll。一些资料把 epoll 比作更"高档"的实现，而 select/poll 是很"low"的实现，这样是不对的，他们都有各自应用的场景，不能一概而论，比如如果套接字大多都是活跃的状态且数量没有到达很大的量级，select 的性能甚至要好过 epoll。本节将提供源代码分别进行描述。

非阻塞 I/O 模型直接轮训查询数据是否准备好，每次查询都要切换内核态，轮询消耗 CPU。而 I/O 多路复用模型则直接把查询多个描述符的动作交给了内核，这样避免了 CPU 消耗和减少了内核态的切换。

## select

同样，可以使用前一节的循环客户端用来测试。可以看到程序中同时监控多个文件描述符。首先将主程序中的监听描述符加入 fd_set,随后监听开始。在主循环中，当有事件发生时，遍历 fd_set，根据不同的情况做出不同的动作。此时若为 accept 则不会阻塞，因为事件已经就续。但是如果是 read 事件，在数据准备阶段不会阻塞，在 I/O 阶段仍会阻塞。

[select](../src/network/advanced_io/select.c ':include')

## poll

poll 模型大体的流程和 select 是一致的。select 使用位图形式的 fd_set，而 poll 使用数组,这解决了 select 中位图最大默认空间 1024 的限制。除此之外，poll 使用 revents 返回修改，每次使用完重置 revents，就可以复用 poll_fd 了，所以不用像 select 一样对原始的 fdset 进行备份。

如下实现中，在移除文件描述符时，仅仅是把对应位置设置为-1,并没有移动被移除的 index 之后的元素，这是较为简便的做法。这样并不会引起性能问题，因为 poll 的数组的填充会从头开始见缝插针的填写，并不会出现 maxfd 前大量未使用的 index 存在。

[poll](../src/network/advanced_io/poll.c ':include')

## epoll

epoll 模型大体的流程和 select 以及 poll 也是一致的。epoll 解决了 select/poll 中存在的集合拷贝的问题，在海量连接数的情况下非常适用，其也是众多知名服务器的核心实现方式。同时，epoll 支持水平触发以及边缘触发两种模式。select/poll 仅支持水平触发模式。

- 水平触发: 在报告 fd 后如果其没有被处理，或者数据没有被全部读取，那么水平触发会立刻继续报告该 fd
- 边缘触发: 在报告 fd 后如果其没有被处理，或者数据没有被全部读取，那么边缘触发会在下次再报告该 fd

和后文将简述的 Windows 下的异步模型 IOCP 类似，二者都可以通过指针携带应用层数据。在 epoll 里，可以通过 epoll_data 里的"void \*ptr"来传递。这是一种很重要的思想，也是它们高效的原因所在：当事件的通知到来时，它不仅告诉你发生了什么样的事件，还同时告诉这次事件所操作的数据是哪些。

[epoll](../src/network/advanced_io/epoll.c ':include')
