# 信号驱动式 I/O 模型

此处所说的信号驱动式 I/O 模型指的是经典的基于套接字的，使用信号的异步 I/O 机制，这种模型在历史上曾被不恰当地称为异步 I/O，这容易引起混淆。此种模式在如 read 等调用在从内核取回数据时依然是阻塞的状态，理论上讲不是一种真正的异步模型。

信号驱动式 I/O 模型可应用在终端输入、管道读写、以及 UDP 套接字(通知意味着到达一个数据报，或者返回一个异步错误)和 TCP 监听套接字(意味着建立连接)中。此模型不适合应用在 TCP 连接套接字，因为 TCP 连接套接字可能触发信号的可能性太多，逐一进行判断得不偿失，并且有些事件亦无法区分。

POSIX 信号通常不排队，这也就意味着，假如 SIGIO 处理函数正在执行，又有两个新的 SIGIO 信号传过来，会被当前处理函数阻塞掉，当当前 SIGIO 函数处理完，最后只有新的一个 SIGIO 会触发继续执行 SIGIO 函数，丢失了一个信号。此种模型在大量 I/O 操作时可能会因为信号队列溢出导致没法通知。

## 信号驱动式 I/O 在终端中的应用

[sig_terminal](../src/network/advanced_io/sig_terminal.c ':include')

## 信号驱动式 I/O 在网络的应用

此节先给出一个在 TCP 监听套接字的应用。注意，在使用信号处理 TCP 监听套接字时，同时你仍需要处理接受客户端数据的各个描述符。

[sig_tcp_listen](../src/network/advanced_io/sig_tcp_listen.c ':include')

下面再给出一个 UDP 回声客户端使用信号驱动式 I/O 的例子，例子中不再需要用轮询的方式收取数据报，在数据报到达时会收到信号，自动调用先前设置好的信号处理程序。此服务端可配合上节的 udp 客户端测试。

[sig_udp_server](../src/network/advanced_io/sig_udp_server.c ':include')
